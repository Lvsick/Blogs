<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lvsick</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blogs/docs/.vuepress/public/home.jpg">
    <meta name="description" content="Lvsick的前端记录">
    
    <link rel="preload" href="/blogs/assets/css/0.styles.cc3ef769.css" as="style"><link rel="preload" href="/blogs/assets/js/app.e1d588d3.js" as="script"><link rel="preload" href="/blogs/assets/js/2.fa9309b5.js" as="script"><link rel="preload" href="/blogs/assets/js/11.21e641df.js" as="script"><link rel="prefetch" href="/blogs/assets/js/10.cf88bf8d.js"><link rel="prefetch" href="/blogs/assets/js/12.4a927b28.js"><link rel="prefetch" href="/blogs/assets/js/13.448de3ae.js"><link rel="prefetch" href="/blogs/assets/js/14.2373f7ae.js"><link rel="prefetch" href="/blogs/assets/js/15.c68a071d.js"><link rel="prefetch" href="/blogs/assets/js/16.3fc7390e.js"><link rel="prefetch" href="/blogs/assets/js/3.1a98bb1e.js"><link rel="prefetch" href="/blogs/assets/js/4.e827a7b6.js"><link rel="prefetch" href="/blogs/assets/js/5.2efeba6a.js"><link rel="prefetch" href="/blogs/assets/js/6.28888ff8.js"><link rel="prefetch" href="/blogs/assets/js/7.528a5f9a.js"><link rel="prefetch" href="/blogs/assets/js/8.58c97b44.js"><link rel="prefetch" href="/blogs/assets/js/9.bff0ee0e.js">
    <link rel="stylesheet" href="/blogs/assets/css/0.styles.cc3ef769.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blogs/" class="home-link router-link-active"><img src="/blogs/home.jpg" alt="Lvsick" class="logo"> <span class="site-name can-hide">Lvsick</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blogs/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blogs/pages/artical/artical1.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/blogs/pages/other/other1.html" class="nav-link">
  琐碎
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blogs/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blogs/pages/artical/artical1.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/blogs/pages/other/other1.html" class="nav-link">
  琐碎
</a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>笔记整理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/pages/artical/artical1.html" aria-current="page" class="active sidebar-link">HTTP请求</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blogs/pages/artical/artical2.html" class="sidebar-link">从输入URL到页面展示，这中间发生了什么？</a></li><li><a href="/blogs/pages/artical/artical3.html" class="sidebar-link">React事件处理函数绑定的相关问题</a></li><li><a href="/blogs/pages/artical/artical4.html" class="sidebar-link">浅拷贝与深拷贝</a></li><li><a href="/blogs/pages/artical/artical5.html" class="sidebar-link">请求头与响应头</a></li><li><a href="/blogs/pages/artical/artical6.html" class="sidebar-link">flutter解析json数据</a></li><li><a href="/blogs/pages/artical/artical7.html" class="sidebar-link">数组操作</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div class="custom-block danger"><p class="custom-block-title">注意</p> <p>笔记参考自<a href="https://time.geekbang.org/column/intro/216?code=0" target="_blank" rel="noopener noreferrer">极客时间-浏览器工作原理与实践<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <h3 id="访问任何网站实际上只是你的计算机向另外一台计算机请求信息。"><a href="#访问任何网站实际上只是你的计算机向另外一台计算机请求信息。" class="header-anchor">#</a> 访问任何网站实际上只是你的计算机向另外一台计算机请求信息。</h3> <div class="custom-block tip"><p class="custom-block-title">过程</p> <p>如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。</p></div> <h3 id="浏览器端发起-http-请求流程"><a href="#浏览器端发起-http-请求流程" class="header-anchor">#</a> 浏览器端发起 HTTP 请求流程</h3> <h4 id="_1-构建请求"><a href="#_1-构建请求" class="header-anchor">#</a> 1. 构建请求</h4> <p><code>GET /index.html HTTP1.1</code></p> <h4 id="_2-查找缓存"><a href="#_2-查找缓存" class="header-anchor">#</a> 2. 查找缓存</h4> <p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</p> <h4 id="_3-准备-ip-地址和端口"><a href="#_3-准备-ip-地址和端口" class="header-anchor">#</a> 3. 准备 IP 地址和端口</h4> <p>浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的。
<img src="https://static001.geekbang.org/resource/image/12/80/1277f342174b23f9442d3b27016d7980.png" alt="">
第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p> <h4 id="_4-等待-tcp-队列"><a href="#_4-等待-tcp-队列" class="header-anchor">#</a> 4. 等待 TCP 队列</h4> <p>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p> <h4 id="_5-建立-tcp-连接"><a href="#_5-建立-tcp-连接" class="header-anchor">#</a> 5. 建立 TCP 连接</h4> <p>排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。</p> <h4 id="_6-发送-http-请求"><a href="#_6-发送-http-请求" class="header-anchor">#</a> 6. 发送 HTTP 请求</h4> <p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。
<img src="https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png" alt="">
首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。另外一个常用的请求方法是 POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</p> <h3 id="questions"><a href="#questions" class="header-anchor">#</a> questions</h3> <h4 id="_1-为什么很多站点第二次打开速度会很快"><a href="#_1-为什么很多站点第二次打开速度会很快" class="header-anchor">#</a> 1.为什么很多站点第二次打开速度会很快？</h4> <p>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。
下面是缓存处理的过程：
<img src="https://static001.geekbang.org/resource/image/5f/08/5fc2f88a04ee0fc41a808f3481287408.png" alt="">
从上图的第一次请求可以看出，当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。</p> <div class="language-js extra-class"><pre class="language-js"><code>Cache<span class="token operator">-</span>Control<span class="token operator">:</span>Max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">2000</span>
</code></pre></div><p>这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：</p> <div class="language-js extra-class"><pre class="language-js"><code>If<span class="token operator">-</span>None<span class="token operator">-</span>Match<span class="token operator">:</span><span class="token string">&quot;4f80f-13c-3a1xb12a&quot;</span>
</code></pre></div><ul><li>如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”</li> <li>如果资源有更新，服务器就直接返回最新资源给浏览器。</li></ul> <h3 id="_2-登录状态是如何保持的"><a href="#_2-登录状态是如何保持的" class="header-anchor">#</a> 2. 登录状态是如何保持的？</h3> <ul><li>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。</li> <li>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Set<span class="token operator">-</span>Cookie<span class="token operator">:</span> <span class="token constant">UID</span><span class="token operator">=</span><span class="token number">3431</span>uad<span class="token punctuation">;</span>
</code></pre></div><ul><li>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。</li> <li>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Cookie<span class="token operator">:</span> <span class="token constant">UID</span><span class="token operator">=</span><span class="token number">3431</span>uad<span class="token punctuation">;</span>
</code></pre></div><ul><li>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</li> <li>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。
Cookie 流程可以参考下图：
<img src="https://static001.geekbang.org/resource/image/d9/b3/d9d6cefe8d3d6d84a37a626687c6ecb3.png" alt=""></li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">10/27/2020, 1:45:04 AM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blogs/pages/artical/artical2.html">
        从输入URL到页面展示，这中间发生了什么？
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blogs/assets/js/app.e1d588d3.js" defer></script><script src="/blogs/assets/js/2.fa9309b5.js" defer></script><script src="/blogs/assets/js/11.21e641df.js" defer></script>
  </body>
</html>
